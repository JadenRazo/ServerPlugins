package net.serverplugins.afk.managers;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import net.serverplugins.afk.ServerAFK;
import net.serverplugins.afk.models.ActivityRecord;
import net.serverplugins.afk.models.PatternAnalysis;
import net.serverplugins.afk.models.PlayerAfkSession;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;

/**
 * Manages anti-exploit pattern analysis and bot detection. Analyzes player behavior patterns to
 * detect automated AFK farming.
 */
public class AntiExploitManager {

    private final ServerAFK plugin;
    private final Map<UUID, List<ActivityRecord>> recentActivity;
    private final Map<UUID, PatternAnalysis> recentAnalysis;
    private final Map<UUID, Integer> suspicionLevel;
    private BukkitTask analysisTask;

    // Configuration
    private boolean enabled;
    private int analysisIntervalSeconds;
    private int activityLogWindowSeconds;
    private int maxActivityRecordsPerPlayer;
    private double suspicionThreshold;
    private int verificationTriggerLevel;

    public AntiExploitManager(ServerAFK plugin) {
        this.plugin = plugin;
        this.recentActivity = new ConcurrentHashMap<>();
        this.recentAnalysis = new ConcurrentHashMap<>();
        this.suspicionLevel = new ConcurrentHashMap<>();

        loadConfig();
    }

    public void start() {
        if (!enabled) {
            plugin.getLogger().info("AntiExploitManager disabled in config.");
            return;
        }

        // Start pattern analysis task
        analysisTask =
                new BukkitRunnable() {
                    @Override
                    public void run() {
                        analyzeAllPlayers();
                    }
                }.runTaskTimerAsynchronously(
                        plugin,
                        600L,
                        analysisIntervalSeconds * 20L); // Run every configured interval

        plugin.getLogger()
                .info(
                        "AntiExploitManager started with analysis every "
                                + analysisIntervalSeconds
                                + " seconds");
    }

    public void stop() {
        if (analysisTask != null) {
            analysisTask.cancel();
        }
        recentActivity.clear();
        recentAnalysis.clear();
        suspicionLevel.clear();
    }

    public final void loadConfig() {
        this.enabled = plugin.getAfkConfig().isAntiExploitEnabled();
        this.analysisIntervalSeconds = plugin.getAfkConfig().getAntiExploitAnalysisInterval();
        this.activityLogWindowSeconds = plugin.getAfkConfig().getAntiExploitActivityWindow();
        this.maxActivityRecordsPerPlayer = plugin.getAfkConfig().getAntiExploitMaxRecords();
        this.suspicionThreshold = plugin.getAfkConfig().getAntiExploitSuspicionThreshold();
        this.verificationTriggerLevel = plugin.getAfkConfig().getAntiExploitVerificationLevel();
    }

    /**
     * Logs an activity record for a player. This is called by ActivityListener for all player
     * actions.
     */
    public void logActivity(ActivityRecord record) {
        if (!enabled) {
            return;
        }

        UUID playerId = record.getPlayerUuid();
        List<ActivityRecord> activities =
                recentActivity.computeIfAbsent(playerId, k -> new ArrayList<>());

        activities.add(record);

        // Keep only recent activities (last N records)
        if (activities.size() > maxActivityRecordsPerPlayer) {
            activities.remove(0);
        }

        // Clean old activities outside the time window
        long cutoffTime = System.currentTimeMillis() - (activityLogWindowSeconds * 1000L);
        activities.removeIf(
                a -> {
                    long activityTime =
                            a.getTimestamp()
                                    .atZone(java.time.ZoneId.systemDefault())
                                    .toInstant()
                                    .toEpochMilli();
                    return activityTime < cutoffTime;
                });
    }

    /** Analyzes all active AFK players for suspicious patterns. */
    private void analyzeAllPlayers() {
        for (UUID playerId : recentActivity.keySet()) {
            Player player = Bukkit.getPlayer(playerId);
            if (player == null || !player.isOnline()) {
                continue;
            }

            PlayerAfkSession session = plugin.getPlayerTracker().getSession(playerId);
            if (session == null) {
                continue; // Not in an AFK session
            }

            analyzePlayer(playerId);
        }
    }

    /** Analyzes a specific player's activity patterns. */
    public void analyzePlayer(UUID playerId) {
        List<ActivityRecord> activities = recentActivity.get(playerId);
        if (activities == null || activities.size() < 10) {
            return; // Not enough data
        }

        double maxConfidence = 0.0;
        PatternAnalysis.PatternType detectedPattern = null;

        // Run various pattern detection algorithms
        double repetitiveMovement = detectRepetitiveMovement(activities);
        if (repetitiveMovement > maxConfidence) {
            maxConfidence = repetitiveMovement;
            detectedPattern = PatternAnalysis.PatternType.REPETITIVE_MOVEMENT;
        }

        double poolRotation = detectPoolRotation(activities);
        if (poolRotation > maxConfidence) {
            maxConfidence = poolRotation;
            detectedPattern = PatternAnalysis.PatternType.POOL_ROTATION;
        }

        double suspiciousTiming = detectSuspiciousTiming(activities);
        if (suspiciousTiming > maxConfidence) {
            maxConfidence = suspiciousTiming;
            detectedPattern = PatternAnalysis.PatternType.SUSPICIOUS_TIMING;
        }

        double noVariance = detectNoVariance(activities);
        if (noVariance > maxConfidence) {
            maxConfidence = noVariance;
            detectedPattern = PatternAnalysis.PatternType.NO_VARIANCE;
        }

        // If confidence exceeds threshold, take action
        if (maxConfidence >= suspicionThreshold && detectedPattern != null) {
            handleSuspiciousPattern(playerId, detectedPattern, maxConfidence);
        }
    }

    /** Detects repetitive movement patterns (same path over and over). */
    private double detectRepetitiveMovement(List<ActivityRecord> activities) {
        List<ActivityRecord> movements =
                activities.stream()
                        .filter(a -> a.getActivityType() == ActivityRecord.ActivityType.MOVEMENT)
                        .collect(java.util.stream.Collectors.toList());

        if (movements.size() < 20) {
            return 0.0;
        }

        // Check if locations repeat in a pattern
        int patternSize = 5;
        int matchCount = 0;
        int totalChecks = 0;

        for (int i = 0; i < movements.size() - patternSize * 2; i++) {
            boolean matches = true;
            for (int j = 0; j < patternSize; j++) {
                ActivityRecord first = movements.get(i + j);
                ActivityRecord second = movements.get(i + j + patternSize);

                if (first.distanceTo(second) > 2.0) { // Allow 2 block variance
                    matches = false;
                    break;
                }
            }
            if (matches) {
                matchCount++;
            }
            totalChecks++;
        }

        return totalChecks > 0 ? (double) matchCount / totalChecks : 0.0;
    }

    /** Detects pool rotation (swimming in circles). */
    private double detectPoolRotation(List<ActivityRecord> activities) {
        List<ActivityRecord> movements =
                activities.stream()
                        .filter(a -> a.getActivityType() == ActivityRecord.ActivityType.MOVEMENT)
                        .collect(java.util.stream.Collectors.toList());

        if (movements.size() < 10) {
            return 0.0;
        }

        // Check if player is moving in a circular pattern
        // Calculate center point and check if all movements are roughly equidistant
        double avgX = movements.stream().mapToInt(ActivityRecord::getLocationX).average().orElse(0);
        double avgZ = movements.stream().mapToInt(ActivityRecord::getLocationZ).average().orElse(0);

        List<Double> distances = new ArrayList<>();
        for (ActivityRecord movement : movements) {
            double dx = movement.getLocationX() - avgX;
            double dz = movement.getLocationZ() - avgZ;
            double distance = Math.sqrt(dx * dx + dz * dz);
            distances.add(distance);
        }

        // Calculate standard deviation
        double mean = distances.stream().mapToDouble(Double::doubleValue).average().orElse(0);
        double variance =
                distances.stream().mapToDouble(d -> Math.pow(d - mean, 2)).average().orElse(0);
        double stdDev = Math.sqrt(variance);

        // Low standard deviation means consistent radius (circular movement)
        if (mean > 2.0 && mean < 10.0 && stdDev < 2.0) {
            return 0.8; // High confidence for pool rotation
        }

        return 0.0;
    }

    /** Detects suspicious timing (too perfect intervals). */
    private double detectSuspiciousTiming(List<ActivityRecord> activities) {
        if (activities.size() < 10) {
            return 0.0;
        }

        // Calculate time intervals between activities
        List<Long> intervals = new ArrayList<>();
        for (int i = 1; i < activities.size(); i++) {
            long time1 =
                    activities
                            .get(i - 1)
                            .getTimestamp()
                            .atZone(java.time.ZoneId.systemDefault())
                            .toInstant()
                            .toEpochMilli();
            long time2 =
                    activities
                            .get(i)
                            .getTimestamp()
                            .atZone(java.time.ZoneId.systemDefault())
                            .toInstant()
                            .toEpochMilli();
            intervals.add(time2 - time1);
        }

        // Calculate standard deviation of intervals
        double mean = intervals.stream().mapToLong(Long::longValue).average().orElse(0);
        double variance =
                intervals.stream().mapToDouble(i -> Math.pow(i - mean, 2)).average().orElse(0);
        double stdDev = Math.sqrt(variance);

        // Very low variance means automated/macro behavior
        double coefficientOfVariation = mean > 0 ? stdDev / mean : 0;

        if (coefficientOfVariation < 0.1) {
            return 0.9; // Very high confidence
        } else if (coefficientOfVariation < 0.2) {
            return 0.6;
        }

        return 0.0;
    }

    /** Detects lack of human variance in behavior. */
    private double detectNoVariance(List<ActivityRecord> activities) {
        // Check for diversity in activity types
        Set<ActivityRecord.ActivityType> uniqueTypes = new HashSet<>();
        for (ActivityRecord activity : activities) {
            uniqueTypes.add(activity.getActivityType());
        }

        // Humans typically perform varied actions
        // Only movement or very few activity types is suspicious
        if (uniqueTypes.size() <= 1) {
            return 0.7;
        } else if (uniqueTypes.size() == 2) {
            return 0.4;
        }

        return 0.0;
    }

    /** Handles a detected suspicious pattern. */
    private void handleSuspiciousPattern(
            UUID playerId, PatternAnalysis.PatternType patternType, double confidence) {
        Player player = Bukkit.getPlayer(playerId);
        if (player == null) {
            return;
        }

        // Update suspicion level
        int level = suspicionLevel.getOrDefault(playerId, 0);
        level++;
        suspicionLevel.put(playerId, level);

        // Create analysis record
        PatternAnalysis analysis = new PatternAnalysis(playerId, patternType, confidence);
        recentAnalysis.put(playerId, analysis);

        // Determine action based on suspicion level
        if (level >= verificationTriggerLevel) {
            // Require verification
            PlayerAfkSession session = plugin.getPlayerTracker().getSession(playerId);
            if (session != null) {
                session.setNeedsVerification(true);
                analysis.setAutoActionTaken(PatternAnalysis.AutoAction.VERIFICATION_REQUIRED);

                // Notify player
                plugin.getAfkConfig().getMessenger().send(player, "verification-required");
            }
        } else {
            // Send warning
            analysis.setAutoActionTaken(PatternAnalysis.AutoAction.WARNING_SENT);
            plugin.getAfkConfig().getMessenger().send(player, "suspicious-activity-warning");
        }

        // Log to database
        plugin.getRepository().savePatternAnalysis(analysis);

        plugin.getLogger()
                .warning(
                        String.format(
                                "Suspicious pattern detected for %s: %s (confidence: %.2f, level: %d)",
                                player.getName(), patternType, confidence, level));
    }

    /** Resets suspicion level for a player (after successful verification). */
    public void resetSuspicion(UUID playerId) {
        suspicionLevel.put(playerId, 0);
        recentAnalysis.remove(playerId);
    }

    /** Gets the current suspicion level for a player. */
    public int getSuspicionLevel(UUID playerId) {
        return suspicionLevel.getOrDefault(playerId, 0);
    }

    /** Checks if anti-exploit is enabled. */
    public boolean isEnabled() {
        return enabled;
    }

    /** Clears activity data for a player when they log out. */
    public void clearPlayerData(UUID playerId) {
        recentActivity.remove(playerId);
        recentAnalysis.remove(playerId);
    }
}
